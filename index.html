<html>
<head>
<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/white.css">
</head>

<body>
<div class="reveal">
<div class="slides">

<section class="title-slide">
<h1>Type-driven data processing</h1>
</section>

<section>
<h2>The data</h2>
<pre>
<code>
id    user_id    kind         ds_begin    ds_end
1     1          inpatient    2019-01-01  2019-01-08
2     1          behavioral   2019-01-08  2019-01-15
3     1          inpatient    2019-01-16  2019-01-17
</code>
</pre>
<p>Multiple aggregations: all spans, just inpatient, etc.</p>
</section>

<section>
<h2>Why SQL</h2>
<p>Readable</p>
<p>Conventional</p>
<p>Performant</p>
<p>Can hire people to write it</p>
</section>

<section>
<h2>Approaches in SQL</h2>
<p>Window functions and <code>case</code> statements</p>
<p>Fancy SQL (recursive CTE, Oracle <code>connect by</code>)</p>
</section>


<section>
<h2>Why not SQL</h2>
<p>Correctness: What about testing?</p>
<p>Idiom: What if iterating is more natural?</p>
<p>Leverage: What about code reuse?</p>
</section>

<section>
<h2>Instead</h2>
<p>Solve case of aggregating spans for one user</p>
<p>Treat the <code>map</code> step separately</p>
</section>

<section>
<h2>Essentials</h2>
<pre>
<code>
class DateSpan:
    def __init__(self, begin, end):
        self.begin = begin
        self.end = end

span1 = DateSpan(
    begin=dt.date(2019, 1, 1),
    end=dt.date(2019, 1, 7),
)
</code>
</pre>
</section>

<section>
<h2>Relations</h2>
<pre>
<code>
class DateSpan:
    ...
    def intersects(self, other):
        if self.begin <= other.begin <= self.end:
            return True
        if self.begin <= other.end <= self.end:
            return True
        return False
</pre>
</code>
</section>


<section>
<h2>Relations: More</h2>
<pre>
<code>
class DateSpan:
    ...
    def adjoins(self, other):
        if (other.begin - self.end).days == 1:
            return True
        if (self.begin - other.end).days == 1:
            return True
        return False
</pre>
</code>
</section>

<section>
<h2>Arithmetic</h2>
<pre>
<code>
class DateSpan:
    ...
    def __add__(self, other):
        if not self.adjoins(other) or self.intersects(other):
            raise ValueError
        lower_bound = min(self.begin, other.begin)
        upper_bound = max(self.end, other.end)
        return self.__class__(begin=lower_bound, end=upper_bound)
</pre>
</code>
</section>

<section>
<h2>Method</h2>
<pre>
<code>
def roll_up(spans, acc=None):
    acc = acc if acc is not None else []

    if spans == []:
        return acc

    current_span = spans[0]
    if acc == []:
        return roll_up(current_span[1:], acc=[current_span])

    last_span = acc[-1]
    if last_span.adjoins(current_span) or last_span.intersects(current_span):
        acc = acc + [current_span + last_span]
    else:
        acc = acc + [current_span]
    return roll_up(current_spans[1:], acc=acc)
</code>
</pre>
</section>


<section>
<h2>Win #1: Correctness</h2>
<p>The code is testable out of the box</p>
<p>The tests of the type and rollup methods are high leverage</p>
<p>The tests for each pipeline task become simple</p>
</section>

<section>
<h2>Win #2: Code reuse</h2>
<p>Very common to share code via state in SQL</p>
<p>Here, the work done is available via import</p>
</section>

<section>
<h2>Win #3: Easy to change</h2>
<p>SQL: Support different definitions with copy and paste</p>
<p>Python: Support different definitions by filtering data or adding another method</p>
</section>

<section>
<h2>At what cost</h2>
<p>Performance</p>
<p>More plumbing</p>
<p>Comfort</p>
</section>

<section>
<h2>Parting thoughts</h2>
<p>SQL is great, but lack of fit can be jarring</p>
<p>Working in Python generates wins, but it's not free</p>
<p>Right choice depends on your team</p>
<p>Compromise: DataFrame API?</p>
<p>Consider: Dask or Spark?</p>
</section>
</div>
</div>

<script src="js/reveal.js"></script>
<script>Reveal.initialize();</script>

</body>
</html>
